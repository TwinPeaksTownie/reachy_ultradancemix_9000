<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/static/favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/static/favicon/favicon.svg" />
    <link rel="shortcut icon" href="/static/favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/static/favicon/apple-touch-icon.png" />
    <link rel="manifest" href="/static/favicon/site.webmanifest" />
    <title>Reachy Ultra Dance Mix 9000</title>
    <link rel="stylesheet" href="/static/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>

<body>
    <div class="container">
        <h1>Reachy Ultra Dance Mix 9000</h1>

        <div id="message" class="message"></div>

        <!-- Mode Selection -->
        <div class="card card-glow">
            <h2>Pick Your Dance Mode</h2>
            <div class="mode-buttons">
                <button class="mode-btn selected" data-mode="live_groove" onclick="selectMode('live_groove')">
                    <span class="mode-name">Unlimited Groove</span>
                </button>
                <button class="mode-btn" data-mode="bluetooth_streamer" onclick="selectMode('bluetooth_streamer')">
                    <span class="mode-name">Bluetooth Streamer</span>
                </button>
                <button class="mode-btn" data-mode="connected_choreographer"
                    onclick="selectMode('connected_choreographer')">
                    <span class="mode-name">Connected Choreographer</span>
                </button>
            </div>

            <!-- Live Groove Settings -->
            <div id="settings-live_groove" class="mode-settings-panel active">
                <h3>F&Â¢K it! We'll do it LIVE!!!</h3>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Intensity</span>
                        <span id="mode-live_groove-intensity-value" class="slider-value">1.00</span>
                    </div>
                    <input type="range" id="mode-live_groove-intensity-slider" min="0.5" max="3.0" step="0.05"
                        value="1.0" oninput="updateModeSlider('live_groove', 'intensity', this.value)">
                    <div style="font-size: 0.75rem; color: #888; margin-top: 4px;">
                        Makes the moves stronger
                    </div>
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Volume Threshold</span>
                        <span id="mode-live_groove-volume_gate_threshold-value" class="slider-value">0.005</span>
                    </div>
                    <input type="range" id="mode-live_groove-volume_gate_threshold-slider" min="0.001" max="0.020"
                        step="0.001" value="0.005"
                        oninput="updateModeSlider('live_groove', 'volume_gate_threshold', this.value)">
                    <div style="font-size: 0.75rem; color: #888; margin-top: 4px;">
                        Recommended settings for a quiet room around 0.003 to 0.005. If you are having trouble set to
                        0.1 and incrementally adjust down until the robot starts dancing.
                    </div>
                </div>

                <!-- Collapsible Move Dampening -->
                <div class="collapsible" id="move-dampening-collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible('move-dampening-collapsible')">
                        <span>Move Dampening</span>
                        <span class="arrow">&#9660;</span>
                    </div>
                    <div class="collapsible-content">
                        <p style="color: #888; margin-bottom: 15px; font-size: 0.85rem;">
                            Adjust the intensity of individual dance moves. Adjust amplitude for each dance move. Check
                            "+ Mirrored" to add a Y-flipped version.
                        </p>
                        <div id="moves-grid" class="moves-grid">
                            <p style="color: #666;">Loading moves...</p>
                        </div>
                        <div class="button-row">
                            <button class="control-btn start-btn" onclick="applyMoves()">Apply</button>
                            <button class="control-btn secondary-btn" onclick="resetMoves()">Reset</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Connected Choreographer Settings -->
            <div id="settings-connected_choreographer" class="mode-settings-panel">
                <h3>Both of you dance like you want to win.</h3>

                <!-- Tabs -->
                <div class="tab-container">
                    <button class="tab-btn active spotify" onclick="openTab('spotify')">Spotify</button>
                    <button class="tab-btn youtube" onclick="openTab('youtube')">YouTube</button>
                </div>

                <!-- Spotify Tab -->
                <div id="tab-spotify" class="tab-content active">
                    <!-- Login Section -->
                    <div id="spotify-login-section" style="display: none;">
                        <p style="text-align: center; color: #ccc; margin-bottom: 20px;">
                            Connect your Spotify Premium account.
                        </p>
                        <details class="setup-accordion" id="setup-details">
                            <summary>
                                <span>First Time Setup (Click Here)</span>
                                <span>&#9660;</span>
                            </summary>
                            <div class="setup-content">
                                <div class="step">
                                    <span class="step-num">1</span>
                                    <div class="step-text">
                                        Go to <a href="https://developer.spotify.com/dashboard" target="_blank"
                                            style="color: var(--light-blue);">Spotify Developer Dashboard</a> and log
                                        in.
                                    </div>
                                </div>
                                <div class="step">
                                    <span class="step-num">2</span>
                                    <div class="step-text">
                                        Click <strong>Create App</strong>. Name it "Reachy".<br>
                                        Set <strong>Redirect URI</strong> to exactly:
                                        <div class="copy-box">
                                            <code
                                                id="redirect-uri-text">http://127.0.0.1:9000/api/spotify/callback</code>
                                            <button class="copy-btn" onclick="copyUri()">Copy</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="step">
                                    <span class="step-num">3</span>
                                    <div class="step-text">
                                        Click Save. Copy the <strong>Client ID</strong> and paste it below.
                                    </div>
                                </div>
                            </div>
                        </details>
                        <div class="client-id-container" style="margin-bottom: 20px;">
                            <label>Spotify Client ID</label>
                            <input type="text" id="custom-client-id" class="url-input"
                                placeholder="e.g. 4a2b6c... (Paste here)" oninput="saveClientId(this.value)">
                        </div>
                        <button class="spotify-btn" onclick="spotifyLogin()">Login with Spotify</button>
                    </div>

                    <!-- Search Section (Post-Login) -->
                    <div id="spotify-search-section" style="display: none;">
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="spotify-search-input" class="url-input" style="margin-bottom: 0;"
                                placeholder="Search Spotify for a song..."
                                onkeypress="if(event.key === 'Enter') searchSpotify()">
                            <button class="spotify-btn" style="flex: 0 0 80px;" onclick="searchSpotify()">Go</button>
                        </div>

                        <div id="spotify-results" class="results-container">
                            <p style="color: #666; text-align: center; margin-top: 20px;">Results will appear here...
                            </p>
                        </div>


                        <div style="margin-top: 10px; text-align: center;">
                            <button id="spotify-dance-btn" class="global-dance-btn spotify"
                                style="width: 50%; margin: 0 auto; display: block;" onclick="handleGlobalDance()">
                                DANCE!
                            </button>
                        </div>
                    </div>
                </div>

                <!-- YouTube Tab -->
                <div id="tab-youtube" class="tab-content">
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="youtube-url" class="url-input" style="margin-bottom: 0;"
                            placeholder="Paste YouTube URL...">
                        <button class="youtube-btn" style="flex: 0 0 80px;" onclick="submitYoutubeUrl()">Go</button>
                    </div>

                    <div id="youtube-results" class="results-container">
                        <p style="color: #666; text-align: center; margin-top: 20px;">Video preview will appear here...
                        </p>
                    </div>


                    <div style="margin-top: 10px; text-align: center;">
                        <button id="youtube-dance-btn" class="global-dance-btn youtube"
                            style="width: 50%; margin: 0 auto; display: block;" onclick="handleGlobalDance()">
                            DANCE!
                        </button>
                    </div>
                </div>

                <!-- Status Terminal -->
                <div id="status-terminal" class="status-terminal">
                    <!-- Logs will appear here -->
                </div>

                <!-- Shared Sliders -->
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Amplitude Scale</span>
                            <span id="mode-connected_choreographer-amplitude_scale-value"
                                class="slider-value">0.50</span>
                        </div>
                        <input type="range" id="mode-connected_choreographer-amplitude_scale-slider" min="0.1" max="1.5"
                            step="0.05" value="0.5"
                            oninput="updateModeSlider('connected_choreographer', 'amplitude_scale', this.value)">
                        <div style="font-size: 0.75rem; color: #888; margin-top: 4px;">Adjust the intensity of the
                            moves.</div>
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Interpolation (LERP)</span>
                            <span id="mode-connected_choreographer-interpolation_alpha-value"
                                class="slider-value">0.30</span>
                        </div>
                        <input type="range" id="mode-connected_choreographer-interpolation_alpha-slider" min="0.05"
                            max="1.0" step="0.05" value="0.3"
                            oninput="updateModeSlider('connected_choreographer', 'interpolation_alpha', this.value)">
                        <div style="font-size: 0.75rem; color: #888; margin-top: 4px;">Smoothing</div>
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Antenna Beat Threshold</span>
                            <span id="mode-connected_choreographer-antenna_energy_threshold-value"
                                class="slider-value">0.25</span>
                        </div>
                        <input type="range" id="mode-connected_choreographer-antenna_energy_threshold-slider" min="0.0"
                            max="0.5" step="0.01" value="0.25"
                            oninput="updateModeSlider('connected_choreographer', 'antenna_energy_threshold', this.value)">
                        <div style="font-size: 0.75rem; color: #888; margin-top: 4px;">Adjust the floor for detecting
                            antenna beats. (beats are harder to trigger)</div>
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Antenna Gain</span>
                            <span id="mode-connected_choreographer-antenna_gain-value" class="slider-value">20.0</span>
                        </div>
                        <input type="range" id="mode-connected_choreographer-antenna_gain-slider" min="1.0" max="50.0"
                            step="1.0" value="20.0"
                            oninput="updateModeSlider('connected_choreographer', 'antenna_gain', this.value)">
                        <div style="font-size: 0.75rem; color: #888; margin-top: 4px;">Increase the energy above
                            threshold. (antenna will move further)</div>
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Antenna Sensitivity</span>
                            <span id="mode-connected_choreographer-antenna_sensitivity-value"
                                class="slider-value">1.0</span>
                        </div>
                        <input type="range" id="mode-connected_choreographer-antenna_sensitivity-slider" min="0.1"
                            max="1.0" step="0.05" value="1.0"
                            oninput="updateModeSlider('connected_choreographer', 'antenna_sensitivity', this.value)">
                        <div style="font-size: 0.75rem; color: #888; margin-top: 4px;">Dampens the antenna onset speed.
                        </div>
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Antenna Max Span</span>
                            <span id="mode-connected_choreographer-antenna_amplitude-value"
                                class="slider-value">3.15</span>
                        </div>
                        <input type="range" id="mode-connected_choreographer-antenna_amplitude-slider" min="0.5"
                            max="3.15" step="0.05" value="3.15"
                            oninput="updateModeSlider('connected_choreographer', 'antenna_amplitude', this.value)">
                        <div style="font-size: 0.75rem; color: #888; margin-top: 4px;">Increase the max range the
                            antenna can travel.</div>
                    </div>
                </div>

                <!-- Global Dance Button -->
                <!-- Global Dance Button Removed -->
            </div>

            <!-- Bluetooth Streamer Settings -->
            <div id="settings-bluetooth_streamer" class="mode-settings-panel">
                <h3>Bluetooth Streamer Settings</h3>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Max Yaw (body sway)</span>
                        <span id="mode-bluetooth_streamer-max_yaw-value" class="slider-value">0.75</span>
                    </div>
                    <input type="range" id="mode-bluetooth_streamer-max_yaw-slider" min="0.1" max="1.5" step="0.05"
                        value="0.75" oninput="updateModeSlider('bluetooth_streamer', 'max_yaw', this.value)">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Max Pitch (head nod)</span>
                        <span id="mode-bluetooth_streamer-max_pitch-value" class="slider-value">0.30</span>
                    </div>
                    <input type="range" id="mode-bluetooth_streamer-max_pitch-slider" min="0.05" max="0.6" step="0.01"
                        value="0.30" oninput="updateModeSlider('bluetooth_streamer', 'max_pitch', this.value)">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Max Z (vertical bounce)</span>
                        <span id="mode-bluetooth_streamer-max_z-value" class="slider-value">0.015</span>
                    </div>
                    <input type="range" id="mode-bluetooth_streamer-max_z-slider" min="0.005" max="0.03" step="0.001"
                        value="0.015" oninput="updateModeSlider('bluetooth_streamer', 'max_z', this.value)">
                </div>
            </div>

            <div class="controls">
                <button id="start-btn" class="control-btn start-btn" onclick="startMode()">Start</button>
                <button id="stop-btn" class="control-btn stop-btn" onclick="stopMode()">Stop</button>
            </div>
        </div>

        <!-- Safety Tuning (Collapsible) -->
        <div class="card">
            <div class="collapsible" id="safety-collapsible">
                <div class="collapsible-header" onclick="toggleCollapsible('safety-collapsible')">
                    <span>Safety Tuning</span>
                    <span class="arrow">&#9660;</span>
                </div>
                <div class="collapsible-content">


                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Smoothing</span>
                            <span id="smoothing-value" class="slider-value">1.000</span>
                        </div>
                        <input type="range" id="smoothing-slider" min="0.01" max="1.0" step="0.01" value="1.0"
                            oninput="updateSlider('smoothing', this.value)">
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Z Threshold (collision)</span>
                            <span id="z-threshold-value" class="slider-value">0.005</span>
                        </div>
                        <input type="range" id="z-threshold-slider" min="0.001" max="0.02" step="0.001" value="0.005"
                            oninput="updateSlider('z_threshold', this.value)">
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Max Pitch at Low Z</span>
                            <span id="max-pitch-value" class="slider-value">0.150</span>
                        </div>
                        <input type="range" id="max-pitch-slider" min="0.05" max="0.3" step="0.01" value="0.15"
                            oninput="updateSlider('max_pitch_at_low_z', this.value)">
                    </div>

                    <button class="control-btn start-btn" style="margin-top: 10px" onclick="applySafetyConfig()">
                        Apply Changes
                    </button>
                </div>
            </div>
        </div>

        <div class="calibration-box">
            <div class="box-label">Calibration Mode</div>
            <label>
                <input type="radio" name="calibration-mode" value="calibrate" checked>
                <span>Calibrate environment on start</span>
            </label>
            <label id="load-profile-label">
                <input type="radio" name="calibration-mode" value="load" id="load-profile-radio" disabled>
                <span id="load-profile-text">Load saved profile (none found)</span>
            </label>
            <div id="profile-status" class="profile-status"></div>
            <button id="save-profile-btn" class="save-profile-btn" onclick="saveProfile()" style="display: none;">
                Save Current Calibration
            </button>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <div class="status-label">Connection</div>
                <div id="connection-status" class="status-value disconnected">---</div>
            </div>
            <div class="status-item">
                <div class="status-label">Mode</div>
                <div id="current-mode" class="status-value">-</div>
            </div>
            <div class="status-item">
                <div class="status-label">State</div>
                <div id="current-state" class="status-value">Idle</div>
            </div>
            <div class="status-item">
                <div class="status-label">BPM / Beat</div>
                <div id="bpm-display" class="status-value">-</div>
            </div>
        </div>
        <div class="progress-bar">
            <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
        </div>
    </div>

    <script>
        const API_BASE = '';  // Same origin
        let selectedMode = 'live_groove';
        let statusInterval = null;
        let ws = null;

        // New State for Connected Choreographer
        let currentTab = 'spotify';
        let selectedItem = null; // { type: 'spotify'|'youtube', data: ... }

        // Toggle collapsible sections
        function toggleCollapsible(id) {
            const el = document.getElementById(id);
            el.classList.toggle('open');
        }

        // Mode selection
        function selectMode(mode) {
            selectedMode = mode;

            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.mode === mode);
            });

            // Show/hide mode settings panels
            document.querySelectorAll('.mode-settings-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(`settings-${mode}`).classList.add('active');

            // Toggle Start Button visibility
            const startBtn = document.getElementById('start-btn');
            if (mode === 'connected_choreographer') {
                startBtn.style.display = 'none';
            } else {
                startBtn.style.display = 'block';
            }

            // Check Spotify status when Connected Choreographer is selected
            if (mode === 'connected_choreographer') {
                checkSpotifyStatus();
                // Ensure a tab is open
                openTab(currentTab);
                // Show terminal
                document.getElementById('status-terminal').classList.add('active');
            } else {
                // Hide terminal for other modes
                document.getElementById('status-terminal').classList.remove('active');
            }
        }

        // Toggle Results Collapse
        function toggleResults(containerId, btn) {
            const container = document.getElementById(containerId);
            container.classList.toggle('collapsed');
            // Update arrow
            if (container.classList.contains('collapsed')) {
                btn.innerHTML = '&#9660;'; // Down arrow
            } else {
                btn.innerHTML = '&#9650;'; // Up arrow
            }
        }

        // Tab Handling
        function openTab(tab) {
            currentTab = tab;

            // Update Tab Buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.classList.contains(tab)) btn.classList.add('active');
            });

            // Update Tab Content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`tab-${tab}`).classList.add('active');

            // Update Dance Button State
            updateGlobalButton();
        }

        function updateGlobalButton() {
            // Check both buttons
            const spotifyBtn = document.getElementById('spotify-dance-btn');
            const youtubeBtn = document.getElementById('youtube-dance-btn');

            // Default disabled
            if (spotifyBtn) spotifyBtn.disabled = true;
            if (youtubeBtn) youtubeBtn.disabled = true;
            if (spotifyBtn) spotifyBtn.classList.remove('ready');
            if (youtubeBtn) youtubeBtn.classList.remove('ready');

            if (selectedItem && selectedItem.type === 'spotify' && spotifyBtn) {
                spotifyBtn.classList.add('ready');
                spotifyBtn.disabled = false;
            }
            if (selectedItem && selectedItem.type === 'youtube' && youtubeBtn) {
                youtubeBtn.classList.add('ready');
                youtubeBtn.disabled = false;
            }
        }

        function selectItem(type, data, elementId) {
            selectedItem = { type, data };

            // Visual Selection
            document.querySelectorAll('.result-item').forEach(el => el.classList.remove('selected'));
            if (elementId) {
                const el = document.getElementById(elementId);
                if (el) el.classList.add('selected');
            }

            updateGlobalButton();
        }

        // Start mode
        async function startMode() {
            const startBtn = document.getElementById('start-btn');
            if (startBtn) startBtn.disabled = true;

            let body = {};

            // Live Groove: Handle calibration options
            if (selectedMode === 'live_groove') {
                const calibrationMode = document.querySelector('input[name="calibration-mode"]:checked').value;
                if (calibrationMode === 'load') {
                    body.profile_path = 'default';
                    body.skip_calibration = false;
                    body.force_calibration = false;
                } else {
                    body.force_calibration = true;
                    body.skip_calibration = false;
                }
            }

            try {
                const res = await fetch(`${API_BASE}/api/mode/${selectedMode}/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Failed to start');
                }

                const modeNames = {
                    'live_groove': 'Live Groove',
                    'bluetooth_streamer': 'Bluetooth Streamer',
                    'connected_choreographer': 'Connected Choreographer'
                };
                const modeName = modeNames[selectedMode] || selectedMode;
                const modeMsg = selectedMode === 'live_groove' ?
                    (body.profile_path ? `Started ${modeName} (loading profile)` : `Started ${modeName} (calibrating)`) :
                    `Started ${modeName}`;
                showMessage(modeMsg, 'success');
            } catch (e) {
                showMessage(e.message, 'error');
            } finally {
                if (startBtn) startBtn.disabled = false;
            }
        }

        // YouTube Logic (Staging)
        function submitYoutubeUrl() {
            const url = document.getElementById('youtube-url').value;
            if (!url) {
                showMessage('Please enter a YouTube URL', 'error');
                return;
            }

            // Create a staged result item
            const resultsDiv = document.getElementById('youtube-results');
            const resultId = 'yt-result-' + Date.now();

            // Simple display
            resultsDiv.innerHTML = `
                <div id="${resultId}" class="result-item" onclick="selectItem('youtube', {url: '${url}'}, '${resultId}')">
                    <img src="https://img.youtube.com/vi/${getYouTubeID(url)}/0.jpg" onerror="this.src='https://via.placeholder.com/60?text=YT'" alt="YT">
                    <div class="result-info">
                        <div class="result-title">YouTube Video</div>
                        <div class="result-subtitle">${url}</div>
                    </div>
                </div>
            `;

            // Auto Select
            selectItem('youtube', { url: url }, resultId);
        }

        function getYouTubeID(url) {
            // Basic extraction
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : 'default';
        }

        // Stop mode
        async function stopMode() {
            try {
                const response = await fetch(`${API_BASE}/api/mode/stop`, {
                    method: 'POST'
                });

                const data = await response.json();
                showMessage('Mode stopped', 'success');
            } catch (error) {
                showMessage('Connection error: ' + error.message, 'error');
            }
        }

        // Spotify Logic
        function copyUri() {
            const text = document.getElementById('redirect-uri-text').textContent;
            navigator.clipboard.writeText(text).then(() => {
                const btn = document.querySelector('.copy-btn');
                const orig = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = orig, 2000);
            });
        }

        function saveClientId(val) {
            localStorage.setItem('spotify_client_id', val.trim());
        }

        function disconnectSpotify() {
            localStorage.removeItem('spotify_client_id');
            location.reload();
        }

        async function checkSpotifyStatus() {
            try {
                const res = await fetch(`${API_BASE}/api/spotify/status`);
                const data = await res.json();

                const loginSection = document.getElementById('spotify-login-section');
                const searchSection = document.getElementById('spotify-search-section');

                if (data.authenticated) {
                    loginSection.style.display = 'none';
                    searchSection.style.display = 'block';
                } else {
                    loginSection.style.display = 'block';
                    searchSection.style.display = 'none';

                    const saved = localStorage.getItem('spotify_client_id');
                    const input = document.getElementById('custom-client-id');
                    if (saved && input) {
                        input.value = saved;
                        document.getElementById('setup-details').open = false;
                    } else {
                        document.getElementById('setup-details').open = true;
                    }
                }
            } catch (e) {
                console.error('Spotify status check failed', e);
            }
        }

        async function spotifyLogin() {
            const cid = document.getElementById('custom-client-id').value.trim();
            if (!cid) {
                document.getElementById('setup-details').open = true;
                document.getElementById('custom-client-id').focus();
                showMessage('Please enter Client ID', 'error');
                return;
            }

            try {
                const res = await fetch(`${API_BASE}/api/spotify/login?client_id=${encodeURIComponent(cid)}`);
                const data = await res.json();

                const width = 500;
                const height = 700;
                const left = (window.screen.width / 2) - (width / 2);
                const top = (window.screen.height / 2) - (height / 2);

                const popup = window.open(data.url, 'Spotify Login', `width=${width},height=${height},top=${top},left=${left}`);

                const poll = setInterval(async () => {
                    if (popup.closed) {
                        clearInterval(poll);
                        checkSpotifyStatus();
                    }

                    try {
                        const res = await fetch(`${API_BASE}/api/spotify/status`);
                        const data = await res.json();
                        if (data.authenticated) {
                            clearInterval(poll);
                            if (!popup.closed) popup.close();
                            checkSpotifyStatus();
                            showMessage('Connected!', 'success');
                        }
                    } catch (e) { }
                }, 1000);

            } catch (e) {
                showMessage('Failed to start login: ' + e.message, 'error');
            }
        }

        async function searchSpotify() {
            const query = document.getElementById('spotify-search-input').value;
            if (!query) return;

            const resultsDiv = document.getElementById('spotify-results');
            resultsDiv.innerHTML = '<p style="color: #888; text-align: center;">Searching...</p>';

            try {
                const res = await fetch(`${API_BASE}/api/spotify/search?q=${encodeURIComponent(query)}`);
                const data = await res.json();

                resultsDiv.innerHTML = '';

                if (data.tracks && data.tracks.items) {
                    data.tracks.items.forEach((track, index) => {
                        const div = document.createElement('div');
                        const resultId = `spotify-track-${index}`;
                        div.id = resultId;
                        div.className = 'result-item';
                        div.onclick = () => selectItem('spotify', track, resultId);

                        const imgUrl = track.album.images[0] ? track.album.images[0].url : '';

                        div.innerHTML = `
                            <img src="${imgUrl}" alt="Album Art">
                            <div class="result-info">
                                <div class="result-title">${track.name}</div>
                                <div class="result-subtitle">${track.artists.map(a => a.name).join(', ')}</div>
                            </div>
                        `;
                        resultsDiv.appendChild(div);
                    });
                } else {
                    resultsDiv.innerHTML = '<p style="color: #888; text-align: center;">No results found.</p>';
                }
            } catch (e) {
                resultsDiv.innerHTML = `<p style="color: var(--pink); text-align: center;">Error: ${e.message}</p>`;
            }
        }

        // GLOBAL DANCE HANDLER
        async function handleGlobalDance() {
            if (!selectedItem) return;

            // Ensure we are in mode
            if (selectedMode !== 'connected_choreographer') {
                selectMode('connected_choreographer');
            }

            try {
                // Check if we need to start the mode
                const statusRes = await fetch(`${API_BASE}/api/status`);
                const statusData = await statusRes.json();

                if (statusData.current_mode !== 'connected_choreographer') {
                    await fetch(`${API_BASE}/api/mode/connected_choreographer/start`, { method: 'POST' });
                }

                if (selectedItem.type === 'spotify') {
                    const res = await fetch(`${API_BASE}/api/mode/connected_choreographer/track`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(selectedItem.data)
                    });

                    if (res.ok) {
                        showMessage(`Playing: ${selectedItem.data.name}`, 'success');
                    } else {
                        throw new Error('Failed to set track');
                    }

                } else if (selectedItem.type === 'youtube') {
                    // Submit URL
                    const res = await fetch(`${API_BASE}/api/mode/connected_choreographer/youtube`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ url: selectedItem.data.url })
                    });

                    if (res.ok) {
                        showMessage('YouTube URL submitted. Analysis starting...', 'success');
                    } else {
                        throw new Error('Failed to submit YouTube URL');
                    }
                }
            } catch (e) {
                showMessage(e.message, 'error');
            }
        }

        async function stopSpotifyPlayback() {
            stopMode(); // Reusing stop logic
        }

        // Update slider display
        function updateSlider(name, value) {
            const displayMap = {
                'intensity': 'intensity-value',
                'smoothing': 'smoothing-value',
                'z_threshold': 'z-threshold-value',
                'max_pitch_at_low_z': 'max-pitch-value'
            };
            document.getElementById(displayMap[name]).textContent = parseFloat(value).toFixed(3);
        }

        // Apply safety config
        async function applySafetyConfig() {
            const config = {
                // intensity: parseFloat(document.getElementById('intensity-slider').value), // Removed from safety
                smoothing_alpha: parseFloat(document.getElementById('smoothing-slider').value),
                z_threshold: parseFloat(document.getElementById('z-threshold-slider').value),
                max_pitch_at_low_z: parseFloat(document.getElementById('max-pitch-slider').value)
            };

            try {
                const response = await fetch(`${API_BASE}/api/safety`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                if (response.ok) {
                    showMessage('Safety config updated', 'success');
                } else {
                    showMessage('Failed to update config', 'error');
                }
            } catch (error) {
                showMessage('Connection error: ' + error.message, 'error');
            }
        }

        // Show message
        function showMessage(text, type) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = 'message ' + type;

            setTimeout(() => {
                msg.className = 'message';
            }, 3000);
        }

        // Poll status
        async function pollStatus() {
            try {
                const response = await fetch(`${API_BASE}/api/status`);
                const data = await response.json();
                updateStatusDisplay(data);
            } catch (error) {
                document.getElementById('connection-status').textContent = 'Error';
                document.getElementById('connection-status').className = 'status-value disconnected';
            }
        }

        // Load current safety config
        async function loadSafetyConfig() {
            try {
                const response = await fetch(`${API_BASE}/api/safety`);
                const config = await response.json();

                if (config.intensity !== undefined) {
                    document.getElementById('intensity-slider').value = config.intensity;
                    document.getElementById('intensity-value').textContent = config.intensity.toFixed(3);
                }
                if (config.smoothing_alpha !== undefined) {
                    document.getElementById('smoothing-slider').value = config.smoothing_alpha;
                    document.getElementById('smoothing-value').textContent = config.smoothing_alpha.toFixed(3);
                }
                if (config.z_threshold !== undefined) {
                    document.getElementById('z-threshold-slider').value = config.z_threshold;
                    document.getElementById('z-threshold-value').textContent = config.z_threshold.toFixed(3);
                }
                if (config.max_pitch_at_low_z !== undefined) {
                    document.getElementById('max-pitch-slider').value = config.max_pitch_at_low_z;
                    document.getElementById('max-pitch-value').textContent = config.max_pitch_at_low_z.toFixed(3);
                }
            } catch (error) {
                console.error('Failed to load safety config:', error);
            }
        }

        // WebSocket connection
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/api/ws`;

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                if (statusInterval) {
                    clearInterval(statusInterval);
                    statusInterval = null;
                }
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                updateStatusDisplay(data);
            };

            ws.onerror = (error) => {
                console.log('WebSocket error, falling back to polling');
                ws.close();
            };

            ws.onclose = () => {
                console.log('WebSocket closed, falling back to polling');
                ws = null;
                if (!statusInterval) {
                    statusInterval = setInterval(pollStatus, 500);
                }
                setTimeout(connectWebSocket, 5000);
            };
        }

        // Update status display from data object
        function updateStatusDisplay(data) {
            const connEl = document.getElementById('connection-status');
            connEl.textContent = data.connected ? 'OK' : 'OFF';
            connEl.className = 'status-value ' + (data.connected ? 'connected' : 'disconnected');

            document.getElementById('current-mode').textContent = data.current_mode || '-';

            if (data.mode_status) {
                const status = data.mode_status;

                document.getElementById('current-state').textContent = status.state || 'Idle';

                let bpmText = '-';
                if (status.bpm) {
                    bpmText = `${status.bpm.toFixed(1)}`;
                }
                if (status.current_beat !== undefined && status.total_beats) {
                    bpmText = `${status.current_beat}/${status.total_beats}`;
                }
                if (status.beat_count !== undefined) {
                    bpmText = `Beat ${status.beat_count + 1}`;
                }
                document.getElementById('bpm-display').textContent = bpmText;

                const progress = (status.progress || 0) * 100;
                document.getElementById('progress-fill').style.width = progress + '%';

                // Update Terminal if in Connected Choreographer
                if (data.current_mode === 'connected_choreographer' && status.logs) {
                    updateTerminal(status.logs);
                }

                // Show save button if Live Groove is calibrated
                const saveBtn = document.getElementById('save-profile-btn');
                if (data.current_mode === 'live_groove' && status.calibrated) {
                    saveBtn.style.display = 'block';
                } else {
                    saveBtn.style.display = 'none';
                }

            } else {
                document.getElementById('current-state').textContent = 'Idle';
                document.getElementById('bpm-display').textContent = '-';
                document.getElementById('progress-fill').style.width = '0%';
                document.getElementById('save-profile-btn').style.display = 'none';
                // Clear/hide terminal if not running or switched mode (handled by selectMode)
            }
        }

        // Update Terminal Display
        function updateTerminal(logs) {
            const term = document.getElementById('status-terminal');
            if (!term) return;

            // Only update if logs changed (simple length check or last item)
            // For now, just rebuild to be safe, but we can optimize if needed.
            // Actually, rebuilding innerHTML every 100ms might be flickering.
            // Let's check last log.
            const lastLog = logs[logs.length - 1];
            if (term.dataset.lastLog === lastLog) return;
            term.dataset.lastLog = lastLog;

            term.innerHTML = logs.map(log => {
                // Detect error logs
                const isError = log.toLowerCase().includes('error') || log.toLowerCase().includes('failed');
                return `<div class="terminal-line ${isError ? 'error' : ''}">${log}</div>`;
            }).join('');

            // Auto scroll to bottom
            term.scrollTop = term.scrollHeight;
        }

        // Move dampening state
        let moveValues = {};
        let mirrorValues = {};
        let mirrorableMoves = [];

        // Load moves from API
        async function loadMoves() {
            try {
                const [movesRes, mirrorRes] = await Promise.all([
                    fetch(`${API_BASE}/api/moves`),
                    fetch(`${API_BASE}/api/moves/mirror`)
                ]);

                const movesData = await movesRes.json();
                const mirrorData = await mirrorRes.json();

                moveValues = movesData.moves || {};
                mirrorValues = mirrorData.mirror || {};
                mirrorableMoves = mirrorData.mirrorable || [];

                renderMoves();
            } catch (error) {
                console.error('Failed to load moves:', error);
                document.getElementById('moves-grid').innerHTML =
                    '<p style="color: var(--pink);">Failed to load moves</p>';
            }
        }

        // Render move sliders in grid
        function renderMoves() {
            const container = document.getElementById('moves-grid');
            const sortedMoves = Object.keys(moveValues).sort();

            if (sortedMoves.length === 0) {
                container.innerHTML = '<p style="color: #666;">No moves available</p>';
                return;
            }

            container.innerHTML = sortedMoves.map(move => {
                const isMirrorable = mirrorableMoves.includes(move);
                const isMirrored = mirrorValues[move] || false;

                return `
                    <div class="move-item">
                        <div class="move-header">
                            <span class="move-name" title="${move}">${move}</span>
                            <span class="move-value" id="move-val-${move}">${moveValues[move].toFixed(2)}</span>
                        </div>
                        <input type="range" class="move-slider"
                            data-move="${move}"
                            min="0" max="2" step="0.05"
                            value="${moveValues[move]}"
                            oninput="updateMoveValue('${move}', this.value)">
                        ${isMirrorable ? `
                            <div class="mirror-toggle">
                                <label>
                                    <input type="checkbox" ${isMirrored ? 'checked' : ''}
                                        onchange="toggleMirror('${move}', this.checked)">
                                    <span>+ Mirrored</span>
                                </label>
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        // Update move value display
        function updateMoveValue(move, value) {
            moveValues[move] = parseFloat(value);
            document.getElementById(`move-val-${move}`).textContent = parseFloat(value).toFixed(2);
        }

        // Toggle mirror for a move
        function toggleMirror(move, checked) {
            mirrorValues[move] = checked;
        }

        // Apply all move changes
        async function applyMoves() {
            try {
                const [dampeningRes, mirrorRes] = await Promise.all([
                    fetch(`${API_BASE}/api/moves`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(moveValues)
                    }),
                    fetch(`${API_BASE}/api/moves/mirror`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(mirrorValues)
                    })
                ]);

                if (dampeningRes.ok && mirrorRes.ok) {
                    showMessage('Move settings saved', 'success');
                } else {
                    showMessage('Failed to update moves', 'error');
                }
            } catch (error) {
                showMessage('Connection error: ' + error.message, 'error');
            }
        }

        // Reset moves to defaults
        async function resetMoves() {
            try {
                const [dampeningRes, mirrorRes] = await Promise.all([
                    fetch(`${API_BASE}/api/moves/reset`, { method: 'POST' }),
                    fetch(`${API_BASE}/api/moves/mirror/reset`, { method: 'POST' })
                ]);

                if (dampeningRes.ok && mirrorRes.ok) {
                    const dampeningData = await dampeningRes.json();
                    const mirrorData = await mirrorRes.json();
                    moveValues = dampeningData.moves || {};
                    mirrorValues = mirrorData.mirror || {};
                    renderMoves();
                    showMessage('Moves reset to defaults', 'success');
                } else {
                    showMessage('Failed to reset moves', 'error');
                }
            } catch (error) {
                showMessage('Connection error: ' + error.message, 'error');
            }
        }

        // Mode settings state
        let modeSettings = {
            live_groove: { intensity: 1.0, volume_gate_threshold: 0.005 },
            connected_choreographer: {
                amplitude_scale: 0.5,
                interpolation_alpha: 0.3,
                antenna_energy_threshold: 0.25,
                antenna_gain: 20.0,
                antenna_sensitivity: 1.0,
                antenna_amplitude: 3.15
            },
            bluetooth_streamer: { max_yaw: 0.75, max_pitch: 0.30, max_z: 0.015 }
        };

        // Load mode settings from API
        async function loadModeSettings() {
            try {
                const response = await fetch(`${API_BASE}/api/mode-settings`);
                const data = await response.json();
                modeSettings = data.settings || modeSettings;
                renderModeSettings();
            } catch (error) {
                console.error('Failed to load mode settings:', error);
            }
        }

        // Render mode settings to sliders
        function renderModeSettings() {
            // Live Groove
            if (modeSettings.live_groove) {
                const intensity = modeSettings.live_groove.intensity || 1.0;
                document.getElementById('mode-live_groove-intensity-slider').value = intensity;
                document.getElementById('mode-live_groove-intensity-value').textContent = intensity.toFixed(2);

                const volThreshold = modeSettings.live_groove.volume_gate_threshold || 0.005;
                document.getElementById('mode-live_groove-volume_gate_threshold-slider').value = volThreshold;
                document.getElementById('mode-live_groove-volume_gate_threshold-value').textContent = volThreshold.toFixed(3);
            }

            // Connected Choreographer
            if (modeSettings.connected_choreographer) {
                const s = modeSettings.connected_choreographer;
                const ampScale = s.amplitude_scale || 0.5;
                const interpAlpha = s.interpolation_alpha || 0.3;
                const antennaThreshold = s.antenna_energy_threshold || 0.25;
                const antennaGain = s.antenna_gain || 20.0;
                const antennaSensitivity = s.antenna_sensitivity || 1.0;
                const antennaAmplitude = s.antenna_amplitude || 3.15;

                document.getElementById('mode-connected_choreographer-amplitude_scale-slider').value = ampScale;
                document.getElementById('mode-connected_choreographer-amplitude_scale-value').textContent = ampScale.toFixed(2);
                document.getElementById('mode-connected_choreographer-interpolation_alpha-slider').value = interpAlpha;
                document.getElementById('mode-connected_choreographer-interpolation_alpha-value').textContent = interpAlpha.toFixed(2);
                document.getElementById('mode-connected_choreographer-antenna_energy_threshold-slider').value = antennaThreshold;
                document.getElementById('mode-connected_choreographer-antenna_energy_threshold-value').textContent = antennaThreshold.toFixed(2);
                document.getElementById('mode-connected_choreographer-antenna_gain-slider').value = antennaGain;
                document.getElementById('mode-connected_choreographer-antenna_gain-value').textContent = antennaGain.toFixed(1);
                document.getElementById('mode-connected_choreographer-antenna_sensitivity-slider').value = antennaSensitivity;
                document.getElementById('mode-connected_choreographer-antenna_sensitivity-value').textContent = antennaSensitivity.toFixed(2);
                document.getElementById('mode-connected_choreographer-antenna_amplitude-slider').value = antennaAmplitude;
                document.getElementById('mode-connected_choreographer-antenna_amplitude-value').textContent = antennaAmplitude.toFixed(2);
            }

            // Bluetooth Streamer
            if (modeSettings.bluetooth_streamer) {
                const maxYaw = modeSettings.bluetooth_streamer.max_yaw || 0.75;
                const maxPitch = modeSettings.bluetooth_streamer.max_pitch || 0.30;
                const maxZ = modeSettings.bluetooth_streamer.max_z || 0.015;
                document.getElementById('mode-bluetooth_streamer-max_yaw-slider').value = maxYaw;
                document.getElementById('mode-bluetooth_streamer-max_yaw-value').textContent = maxYaw.toFixed(2);
                document.getElementById('mode-bluetooth_streamer-max_pitch-slider').value = maxPitch;
                document.getElementById('mode-bluetooth_streamer-max_pitch-value').textContent = maxPitch.toFixed(2);
                document.getElementById('mode-bluetooth_streamer-max_z-slider').value = maxZ;
                document.getElementById('mode-bluetooth_streamer-max_z-value').textContent = maxZ.toFixed(3);
            }
        }

        // Update mode slider display and auto-apply
        function updateModeSlider(mode, setting, value) {
            // Mode is now the full name like 'live_groove', 'bluetooth_streamer', etc.
            if (!modeSettings[mode]) modeSettings[mode] = {};
            modeSettings[mode][setting] = parseFloat(value);

            const decimals = setting === 'max_z' || setting === 'volume_gate_threshold' ? 3 : 2;
            document.getElementById(`mode-${mode}-${setting}-value`).textContent =
                parseFloat(value).toFixed(decimals);

            // Auto-apply mode settings on change
            applyModeSettingSingle(mode, setting, parseFloat(value));
        }

        // Apply a single mode setting
        async function applyModeSettingSingle(mode, setting, value) {
            try {
                await fetch(`${API_BASE}/api/mode-settings/${mode}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ [setting]: value })
                });
            } catch (error) {
                console.error('Failed to apply setting:', error);
            }
        }

        // Profile Management
        let profileExists = false;

        async function loadProfileStatus() {
            try {
                const res = await fetch(`${API_BASE}/api/profile/status`);
                const data = await res.json();

                const loadRadio = document.getElementById('load-profile-radio');
                const loadText = document.getElementById('load-profile-text');
                const loadLabel = document.getElementById('load-profile-label');
                const profileStatus = document.getElementById('profile-status');

                profileExists = data.exists;

                if (data.exists && !data.error) {
                    let dateStr = 'unknown time';
                    if (data.created && data.created !== 'unknown') {
                        const date = new Date(data.created);
                        dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    }

                    loadRadio.disabled = false;
                    loadRadio.checked = true; // Auto-select load
                    loadLabel.classList.remove('disabled');
                    document.getElementById('load-profile-text').textContent =
                        `Load saved profile (Created: ${dateStr})`;
                    profileStatus.innerHTML = `<span style="color: var(--light-green);">&#10003;</span> Profile saved: ${dateStr}`;

                    // Uncheck calibrate
                    const calRadio = document.querySelector('input[name="calibration-mode"][value="calibrate"]');
                    if (calRadio) calRadio.checked = false;

                } else {
                    loadRadio.disabled = true;
                    loadLabel.classList.add('disabled');
                    loadText.textContent = 'Load saved profile (none found)';

                    const calRadio = document.querySelector('input[name="calibration-mode"][value="calibrate"]');
                    if (calRadio) calRadio.checked = true;

                    if (data.error) {
                        profileStatus.textContent = 'Error checking profile';
                    } else {
                        profileStatus.textContent = 'No saved profile - calibrate first';
                    }
                }
            } catch (error) {
                console.error('Failed to load profile status:', error);
            }
        }

        async function saveProfile() {
            const saveBtn = document.getElementById('save-profile-btn');
            const originalText = saveBtn.textContent;
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';

            try {
                const res = await fetch(`${API_BASE}/api/profile/save`, {
                    method: 'POST'
                });

                if (res.ok) {
                    const data = await res.json();
                    showMessage('Profile saved successfully!', 'success');
                    // Refresh profile status to update the load option
                    await loadProfileStatus();
                } else {
                    const err = await res.json();
                    showMessage(err.detail || 'Failed to save profile', 'error');
                }
            } catch (error) {
                showMessage('Error saving profile: ' + error.message, 'error');
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = originalText;
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadSafetyConfig();
            loadModeSettings();
            loadMoves();
            loadProfileStatus();
            connectWebSocket();
            pollStatus();
            statusInterval = setInterval(pollStatus, 500);
        });
    </script>
</body>

</html>